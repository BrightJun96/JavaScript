> 클래스 필드는 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어이다.

> 클래스필드로 정의하면 인스턴스의 프로퍼티나 메서드가 된다.

> 클래스필드는 함수 몸체에서 키워드 없이 변수에 할당하면 인스턴스의 프로퍼티나 메서드가 된다.
    (클래스의 prototype이 되는 것이 아님!)

> private 필드는 외부에서 접근할 수 없다.
    private로 정의할 때는 프로퍼티나 메서드 앞에 #을 붙인다.
    constructor에 처음부터 직접적으로 정의하면 안된다.

> private 필드는 클래스 몸체에서 정의하고 매개변수에 따라 초기화하고 싶다면 constructor에서 초기화하면 된다.

> 정적 프로퍼티 및 메서드를 private하게 정의할 때에는 static #변수 를 해주면 된다.

> extends 키워드는 클래스간 상속을 해줄 수 있는 키워드이다.
    클래스간 상속뿐만 아니라 prototype도 상속이 된다.

> 클래스는 생성자함수도 상속받을 수 있다.
    하지만 생성자함수는 클래스를 상속받을 수 없다ㅏ.
    예) 클래스 extends 생성자 함수 => o 
        생성자 함수 extends 클래스  => x


> sub class가 별도의 프로퍼티 추가없이 super class의 프로퍼티를 쓴다면 constructor를 생략해도 된다.

> 하지만 sub class가 super class를 상속받으면서 별도의 프로퍼티를 추가한다면 sub class의 constructor를 생략하면 안되고
    슈퍼클래스의 인수를 super를 통해 전달해야한다.

> sub class에서 constructor를 생략하지 않았다면 constructor 내에서 무조건 super를 호출해줘야한다. 

> sub class의 constructor에서 super호출전까지 this를 참조할 수 없다.

> super는 서브클래스의 constructor에서만 호출할 수 있다.

> 서브클래스의 메서드(프로토타입 메서드) 내에서 super.수퍼클래스 메서드를 호출하면 
    슈퍼클래스의 메서드(프로토타입 메서드)를 호출가능하다.
    (여기서 super는 슈퍼클래스의 prototype을 가리킨다.)

> super는 객체리터럴에서도 참조할 수 있다. 단, 메서드 축약표현에서만 참조가능하다.
    메서드 축약표현만이 [[HomeObject]]라는 내부슬롯을 갖기 때문이다.

> 서브클래스 내에서 슈퍼클래스 정적메서드를 불러오기 위해서는 서브클래스의 정적 메서드 내에서 
    super를 호출하면 된다.

> super는 constructor, 메서드(프로토타입 메서드), 정적 메서드 내에서 참조가능하다.

> 슈퍼클래스의 정적메서드,프로퍼티나 메서드는 서브클래스에서 super과정을 안거치고 쓸 수 있다.

> 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다.
    이것이 바로 서브클래스의 constructor에서 빈드시 super를 호출해야되는 이유이다.

> 서브클래스의 super는 슈퍼클래스의 인스턴스를 전달받은 실체이다.
이러한 이유로 super전에 this를 참조할 수 없는것!